# [chapter19.md] 训练配方：从 1B 到 10B 的生产级方案

### 开篇段落

本章是整个预训练项目的“总装图”与“操作手册”，我们将前述所有关于数据、架构和基建的理论知识，凝聚成一份可执行、可复现的生产级“训练配方”。学习本章，您将不仅获得为 1B Dense 和 10B MoE 两种规模的多模态大模型设定超参数的具体数值，更将深入理解这些数值背后的原理、权衡与规模化法则（scaling laws）。我们将庖丁解牛般剖析学习率、批尺寸、序列打包、数据混合、混合损失函数以及至关重要的吞吐量预估等核心环节。本章的目标是赋能 AI Scientist 设计出稳定高效的训练策略，并为 Infra 工程师提供清晰的性能目标与监控重点，确保这次昂贵而漫长的预训练任务能够精准、稳健地驶向终点。

### 文字论述

#### 19.1 学习率/批尺寸/采样调度（cosine/one-cycle）

训练的成败始于优化器及其调度策略的精妙设计。对于参数量动辄上亿的大模型，任何微小的配置失误都可能导致灾难性的后果，如训练发散、收敛缓慢或陷入糟糕的局部最优。

*   **优化器 (Optimizer)**：我们坚定地选择 **AdamW**。相较于经典的 Adam，AdamW 将权重衰减（weight decay）从梯度更新中解耦，直接作用于权重本身，这在实践中被证明能带来更好的泛化性能和训练稳定性。
    *   **`betas`**: 设为 `(0.9, 0.95)`。`beta1` 控制梯度的一阶矩（动量），`beta2` 控制二阶矩（自适应学习率）。将 `beta2` 设为 `0.95` 而非默认的 `0.999`，可以减少梯度的方差估计，使学习过程在处理大规模、高维度数据时更加平滑，有效抑制了训练初期的尖峰（spikes）。
    *   **`epsilon`**: `1e-8` 是一个标准的安全设置，防止在梯度二阶矩极小的情况下出现除零错误。
    *   **`weight_decay`**: 这是一个关键的正则化项，用于惩罚过大的权重以防止过拟合。其取值与模型规模和数据量强相关，通常在 `0.01` 到 `0.1` 之间。对于 10B 规模的模型，倾向于取较大的值（如 `0.1`）。

*   **批尺寸 (Batch Size)**：在分布式训练中，我们必须区分三个概念：
    1.  **微批尺寸 (Micro-Batch Size)**：单张 GPU 一次前向/后向计算处理的样本数。受限于单卡 80GB 显存，通常设为 4、8 或 16。
    2.  **梯度累积步数 (Gradient Accumulation Steps)**：在执行一次优化器更新（`optimizer.step()`）前，累积多少个微批次的梯度。这是在不增加显存消耗的情况下，有效增大批尺寸的常用技巧。
    3.  **全局批尺寸 (Global Batch Size, GBS)**：这是真正影响模型学习动态的参数，单位通常是 **tokens**。
        `GBS (tokens) = Micro-Batch Size × Seq Length × Grad Accumulation Steps × Data Parallel Size`

    **Rule-of-Thumb**: 在算力预算内，将 GBS 推向极限，通常目标在 **2M 到 4M tokens**。更大的 GBS 提供了更稳定的梯度估计，允许使用更高的学习率，从而可能加速收敛。然而，过大的 GBS 也可能导致模型收敛到泛化能力较差的“尖锐”最小值。

*   **学习率调度器 (Learning Rate Scheduler)**：我们采用业界验证的黄金组合：**带线性预热的余弦退火 (Cosine Decay with Linear Warmup)**。

    ```ascii
      Peak LR +--------------+
              /|              |\
             / |              | \
            /  |              |  \
    LR     /   |   Cosine     |   \
          /    |   Decay      |    \
         /     |              |     \
        /      |              |      \
    ---+-------+--------------+-------> Min LR (e.g., 0.1 * Peak LR)
       |Warmup | Main Training| Cool-down
       <------> <------------>
                Total Training Steps
    ```
    *   **预热 (Warmup)**：在训练启动时，模型权重是随机的，梯度方向极不稳定。我们从一个极小的 LR（如峰值的 1%）开始，经过数千步线性增长到峰值 LR。这给了模型一个“缓冲期”，使其初步适应数据分布，避免早期发散。预热步数通常占总训练步数的 1% - 5%。对于 10T token / 4M GBS = 2.5M steps 的训练，预热 3k-5k 步是合理的。
    *   **峰值 LR (Peak LR)**：这是整个训练中学习率能达到的最高点。
        *   **1B 模型**: `3e-4` 到 `6e-4`。这是一个较为激进但高效的范围。
        *   **10B 模型**: `1e-4` 到 `2e-4`。模型越大，参数空间越复杂，通常需要更小的学习率来保证探索的稳定性。
    *   **退火 (Decay)**：预热结束后，LR 遵循余弦曲线平滑下降。这种策略使得训练的大部分时间都维持在较高的学习率以充分探索，而在训练后期逐降低学习率，帮助模型在已经找到的“盆地”中精细收敛，找到更优的点。

#### 19.2 长序列/多模态序列打包与高效填充（多摄时间对齐）

GPU 是为大规模并行计算而生的，其效率在处理长序列时远高于处理大量填充（padding）的短序列。**序列打包 (Sequence Packing)** 是将 MFU（模型 FLOPs 利用率）从 50-60% 提升至 90% 以上的关键技术。

*   **核心机制**：将多个逻辑上独立的短序列在物理上拼接成一个接近 `max_seq_len` 的长序列。其灵魂在于一个精心构造的 **注意力掩码 (Attention Mask)**。这是一个二维矩阵，`mask[i, j]=1` 表示 token `i` 可以关注 token `j`，否则为 `0`。对于打包序列，该掩码呈现块对角结构，严格限制了注意力计算的范围，确保信息不会在独立样本间泄露。

*   **多模态打包的挑战与方案**：
    1.  **模态与结构边界**：我们使用丰富的特殊 token 来界定结构。例如：`<|video_start|> <|timestamp_1.0s|> <|cam_front|> P...P <|cam_left|> P...P ... <|video_end|>`。这些特殊 token 不仅是分隔符，它们本身也拥有可学习的嵌入向量，向模型传递结构化的元信息。
    2.  **时间与空间对齐**：对于 **6-camera 环视视频**，这是 VLA 和自动驾驶场景的命脉。数据加载器必须保证在打包时，同一时间戳 `t` 的 6 个视频帧（或 tubelet）、对应的音频片段、IMU 读数、文本字幕等被视为一个不可分割的“时间切片组”。打包器在拼接时，会优先将连续的时间切片组放在一起，以利于模型学习时序动态。
    3.  **异构 Token 流**：一个打包好的序列可能是这样的混合体：
        ```
        [Text Tokens] <|video_start|> [Vision Patches for Cam1@T1] [Vision Patches for Cam2@T1] ... <|audio_start|> [Audio Codec Tokens@T1] <|eos|> <bos> [Text Tokens from Sample 2] ...
        ```
        数据加载器需要一个智能的“装箱”算法，动地组合不同长度、不同模态的样本，以最大化每个打包序列的有效 token 比例。

#### 19.3 数据混合温度与阶段化（Cold→Mid→Hot）

一次成功的预训练不是简单地将所有数据混合在一起然后一味地训练。我们采用一种精心设计的课程学习（Curriculum Learning）策略，通过动态调整数据混合比例，引导模型分阶段地掌握不同层次的能力。

*   **阶段一：冷启动 (Cold Start)** [前 1T token]
    *   **数据构成**：以高质量、低噪声、结构化的“教科书”数据为主。包括：合成的 Phi-3 式文本、精选代码库、学术论文（arXiv）、高质量维基百科、清洗过的书籍。在多模态侧，则是高分辨率的图像-文本对、有清晰转录的播客和公开课。
    *   **混合温度 (T)**：较低 (e.g., `T=1.2`)。我们使用温度采样公式来决定从哪个数据集中抽样：
        $$ P(D_i) = \frac{n_i^{1/T}}{\sum_{j} n_j^{1/T}} $$
        其中 `n_i` 是数据集 `D_i` 的大小。较低的 `T` 会放大规模效应，使得模型更频繁地看到那些我们认为质量最高的大型数据集。
    *   **目标**：构建模型的“世界观”骨架。让模型快速、无歧义地学习语言的语法结构、基础物理世界规律、跨模态的基本对应关系（例如，“狗”的文字、图片和声音）。

*   **阶段二：中盘泛化 (Mid-training)** [1T - 9T token]
    *   **数据构成**：全面引入多样性。大规模、经过清洗过滤的网络抓取数据（如 Common Crawl 的一个子集）、YouTube 视频、社交媒体图片等成为主力。此时，数据的广度优先于深度。
    *   **混合温度 (T)**：调高 (e.g., `T=3.0` to `5.0`)。较高的温度会“压平”采样分布，让那些规模较小但内容独特的长尾数据集（如特定领域的论坛、方言语音库）有更多机会被模型看到。
    *   **目标**：用海量的真实世界数据填充模型的血肉，提升其在种噪声、风格和场景下的鲁棒性和泛化能力。

*   **阶段三：热身冲刺 (Hot Finish)** [最后 1T token]
    *   **数据构成**：重新聚焦于高质量和目标领域数据。可以增加指令/对话数据集、VLA 轨迹数据、高质量驾驶视频的比例。
    *   **混合温度 (T)**：再次降低 (e.g., `T=1.5`)，以强化模型在特定任务格式和高价值知识上的记忆。
    *   **目标**：为后续的指令微调（SFT）和对齐阶段“预热”，使模型对下游任务的格式更敏感，减少对齐阶段的负担。

#### 19.4 正负样本与 InfoNCE/CE 混合损失（多模）

我们的模型是生成-理解一体的架构，因此损失函数也需要兼顾两方面的能力。

1.  **自回归交叉熵损失 (Autoregressive Cross-Entropy Loss)**：这是模型生成能力的基础。对于一个多模态 token 序列 `S = {t_1, t_2, ..., t_L}`，损失函数是预测下一个 token 的负对数似然之和：
    $$ \mathcal{L}_{\text{CE}} = - \sum_{i=1}^{L} \log P(t_i | t_{<i}, \mathcal{C}) $$
    其中 `C` 是上下文，包含了所有模态的输入。

2.  **对比学习损失 (InfoNCE Loss)**：为了强化跨模态表征的对齐，我们引入对比学习。具体做法是：从每个多模态样本中，提取出各个模态的整体表征（例如，通过一个特殊的 `[CLS]` token 或者对所有 token 的表征进行平均池化）。对于一个（视频 `V`, 文本 `T`）正样本对，我们在一个全局批次内将其余 `N-1` 个样本的文本 `T_j` 作为负样本。
    $$ \mathcal{L}_{\text{InfoNCE}}(V, T) = - \log \frac{\exp(\text{sim}(E_V, E_T) / \tau)}{\sum_{j=1}^{N} \exp(\text{sim}(E_V, E_{T_j}) / \tau)} $$
    其中 `E` 是模态编码器输出的表征，`sim` 是余弦相似度，`τ` 是温度超参数（通常设为 0.07 左右），它控制着正负样本区分的难易程度。

3.  **VLA 行动预测损失 (Action Prediction Loss)**：对于包含行动（Action）数据的样本，我们对行动 token 施加额外的损失。如果行动是离散的（如“点击按钮 A”），则使用交叉熵损失。如果行动是连续的（如 `[steer: -0.2, throttle: 0.5]`），则使用 L2 回归损失。
    $$ \mathcal{L}_{\text{Action}} = \frac{1}{M} \sum_{k=1}^{M} \| a_k - \hat{a}_k \|^2_2 $$

最终的总损失是三者的加权和：
$$ \mathcal{L}_{\text{total}} = \mathcal{L}_{\text{CE}} + \lambda_1 \cdot \mathcal{L}_{\text{InfoNCE}} + \lambda_2 \cdot \mathcal{L}_{\text{Action}} $$
权重 `λ1` 和 `λ2` 是需要仔细调整的超参数，用以平衡模型的生成流畅性、跨模态理解深度和行动执行精度。

#### 19.5 吞吐建模与算力-时长预算 **[里程碑 W9]**

在按下“启动”按钮前，一份精确的成本与时间预算是项目管理的核心。

*   **核心性能指标**：**模型 FLOPs 利用率 (Model FLOPs Utilization, MFU)**。它衡量了实际达到的有效计算速度与理论峰值的比值。
    *   **MFU** = `实际观测到的 TFLOPS / 模型理论 TFLOPS`
    *   对于 A100/H100 上的大规模训练，一个经过优化的 Megatron-LM 实现，其 MFU 目标应在 **45% - 55%**。低于 40% 意味着存在严重的系统瓶颈（I/O、通信或软件开销）。

*   **单 Token 计算量 (FLOPs/token)**：
    *   Dense Transformer: `FLOPs ≈ 2 × N_params` (一次 FWD+BWD)
    *   MoE Transformer: `FLOPs ≈ 2 × (N_shared + k × N_expert)`，其中 `k` 是激活的专家数。

*   **10B MoE 模型训练时长预估 (示例)**:
    *   **硬件**: 256 × H100 80GB GPU. 单卡 FP8 理论峰值 ≈ 2000 TFLOPS.
    *   **集群理论总算力**: 256 × 2000 TFLOPS = 512 PFLOPS.
    *   **目标 MFU**: 50%. **集群有效算力**: 512 × 0.5 = 256 PFLOPS.
    *   **模型**: 10B MoE, 激活 2 个专家, 有效参数量约为 2.5B。
    *   **FLOPs/token**: `2 × 2.5B ≈ 5 GFLOPs`.
    *   **总计算量**: `10T tokens × 5 GFLOPs/token = 5 × 10^{12} × 5 × 10^9 = 2.5 × 10^{22} FLOPs = 25 ZFLOPs`.
    *   **预估总时长 (秒)**: `总计算 / 集群有效算力 = 2.5 × 10^{22} / (256 × 10^{15}) ≈ 9.76 × 10^4 秒`.
    *   **预估总时长 (天)**: `97600 / (3600 × 24) ≈ 11.3 天`. (这是纯计算时间，实际需考虑I/O、checkpoint、维护等开销，乘以 1.2-1.3 的 buffer 较为现实)。

**[里程碑 W9]** 团队完成小规模（如 1B 模型跑 1T token）的吞吐测试，校准 MFU 达到 45% 以上，并基于此冻结 10T token 主训练的最终时长和成本预算。

#### 19.6 1B Dense 端到端基线复现实验 **[里程碑 W10]**

在启动耗资巨大的 10B 模型训练前，用 1B 的 Dense 模型进行一次全流程的“带妆彩排”是不可或缺的风险控制环节。

*   **彩排目标**：
    1.  **数据链路验证**：从对象存储，经过数据加载、预处理、多模态打包，到送入 GPU，整个数据流是否通畅、高效、无误。
    2.  **软件栈集成测试**：Megatron 的并行配置（TP/PP/DP）、FP8 训练（TransformerEngine）、检查点机制、监控系等是否协同工作正常。
    3.  **模型行为初步观察**：损失曲线是否平稳下降？梯度范数是否在合理范围？是否存在数值不稳定问题？

*   **1B Dense 基线配方 (参考)**：
    | 超参数 | 建议值 | 备注 |
    | :--- | :--- | :--- |
    | Global Batch Size | 2M tokens | 在 256 卡上易于实现 |
    | Peak Learning Rate | 5e-4 | 1B 规模模型的典型值 |
    | Warmup Steps | 3000 steps | 约 10-15B tokens |
    | Max Sequence Length | 4096 | 平衡性能与显存 |
    | Weight Decay | 0.05 | 中等强度的正则化 |
    | Adam Betas | (0.9, 0.95) | 稳定训练的标准配置 |
    | 优化器状态精度 | BF16 | 节省显存，性能几乎无损 |

**[里程碑 W10]** 1B Dense 模型成功跑通 100B token 的短程训练。损失曲线符合预期，MFU 稳定在目标区间，无重大 bug。这次成功的试跑为 10B 模型的启动扫清了障碍。

#### 19.7 10B 先进 MoE 主训练与监控面板 **[里程碑 W12–W18]**

这是项的核心战役。10B MoE 模型不仅规模更大，其稀疏激活的特性也带来了独特的挑战和监控需求。

*   **10B MoE 配方 (参考)**：
    | 超参数 | 建议值 | 备注 |
    | :--- | :--- | :--- |
    | Global Batch Size | 4M tokens | 充分利用集群规模 |
    | Peak Learning Rate | 1.5e-4 | 更大模型，更小 LR 以求稳定 |
    | Warmup Steps | 5000 steps | 预热更长，适应更复杂的模型 |
    | Max Sequence Length | 8192 | 提升长上下文处理能力 |
    | Weight Decay | 0.1 | 更强的正则化以应对更大容量 |
    | Adam Betas | (0.9, 0.95) | 保持不变 |
    | Expert Parallelism | 8 or 16 | 根据 MoE 专家数和网络拓扑决定 |
    | Capacity Factor | 1.25 | 允许 25% 的专家容量冗余 |

*   **MoE 专属监控仪表盘 (必备)**：
    1.  **专家负载均衡 (Expert Load Balancing)**：以直方图形式实时展示每个专家处理的 token 数量。
        *   **健康状态**: 所有专家的负载大致均匀，呈平分布。
        *   **异常状态**: “路由坍塌”，少数几个专家处理了绝大部分 token，形成尖锐的峰。
    2.  **路由辅助损失 (Auxiliary Load Balancing Loss)**：监控该损失项。它应在训练初期快速下降，然后在一个较低的水平上平稳波动。若持续上升，说明路由机制正在失效。
    3.  **门控网络激活统计 (Gating Activations)**：监控门控网络输出的权重（logits）的均值和方差。这可以揭示路由器的“决策健康度”。
    4.  **Token 掉落率 (Token Drop Rate)**：如果专家容量（Capacity）不足，部分 token 会被“丢弃”。这个比率必须持续保持在接近 0%（如 <0.1%）。任何显著的掉落都意味着计算资源的浪费和模型性能的损失。

**[里程碑 W12–W18]** 10B MoE 模型主预训练正式启动并按计划推进。7x24 小时的值班团队紧盯监控面板，确保在长达数周的训练周期内，系统稳定运行，各项 MoE 指标健康，最终完成 10T token 的训练目标。

---

### 本章小结

本章提供了一份详尽的、从 1B 到 10B 规模的多模态大模型生产级训练手册。
*   **优化与调度**：我们确立了以 AdamW 和余弦退火学习率调度器为核心的优化策略，并深入探讨了 `beta2`、`weight_decay` 等关键参数的选择依据。
*   **效率与性能**：通过精细的多模态序列打包技术，我们解决了异构数据带来的效率挑战，将硬件利用率推向极致。时间对齐是 VLA 场景成功的基石。
*   **课程化学习**：“冷→中→热”三阶段数据混合策略，通过动态调整采样温度，实现了从构建基础到泛化再到强化的科学学习路径。
*   **多目标损失**：我们设计了融合交叉熵、InfoNCE 对比学习和行动预测的混合损失函数，确保模型在生成、理解、对齐和行动四个维度上均衡发展。
*   **工程化保障**：强调了基于 MFU 的精确吞吐建模对于项目预算和时管理的重要性，并通过 1B 基线试跑作为风险缓释的关键步骤。对于 10B MoE 模型，我们定义了其特有的监控指标，为大规模训练的稳定性保驾护航。

---

### 常见陷阱与错误 (Gotchas)

1.  **学习率与批尺寸的“经典”误配**：将小模型（如 BERT）的 `5e-5` LR 错误地应用到 GBS 为 4M 的大模型上，导致训练“停滞不前”。反之，在未充分预热的情况下使用过高的 LR，导致 loss 在前几百步就变成 `NaN`。
    *   **调试技巧**：执行“LR Range Test”：用一个极小的 LR 开始，在几百步内指数级地增大 LR，绘制 loss-LR 曲线，找到 loss 开始下降最快的 LR 区域作为峰值 LR 的参考。始终确保预热足够长。

2.  **序列打包中的“幽灵”注意力**：注意力掩码实现中的一个 off-by-one 错误，或对特殊 token 的处理不当，可能导致一个样本的最后一个 token 意外地看到了下一个样本的第一个 token。
    *   **调试技巧**：编写一个独立的脚本，加载数据并生成一个微批次的数据，然后将打包后的 `input_ids` 和 `attention_mask` 可视化。打印出掩码矩阵，并手动抽查几个关键位置（如样本边界、模态边界），确认其值为 0 或 1 是否符合逻辑。

3.  **MoE 路由坍塌的“死亡螺旋”**：由于某些原因（如初始化不当、数据分布剧变），少数专家开始获得略多于平均的 token。这使得它们被训练得更好，从而吸引更多 token，形成正反馈，最终导致负载严重失衡。
    *   **调试技巧**：除了监控负载均衡损失，还要监控路由门控的梯度范数。如果某些专家的门控梯度持续远大于其他专家，说明可能出现了问题。可以尝试引入门控噪声（Gating Noise）或增加负载均衡损失的权重 `λ_aux` 来打破这种正反馈。

4.  **跨模态时间戳的“微秒级”漂移**：在数据预处理管道中，由于不同模态文件的时间戳精度不同（例如，视频帧是毫秒级，IMU 是微秒级），或者处理软件的浮点数误差累积，导致原本对齐的数据产生微小的时间偏差。
    *   **调试技巧**：在数据样本进入打包器之前，设立一个严格的“同步检查点”。将所有模态数据的时间戳转换为统一的整数单位（如纳秒），并断言（assert）同一时间切片组内的所有数据项时间戳误差小于一个阈值（如 1ms）。

5.  **检查点 I/O 风暴**：在 256 个节点上同时向一个共享文件系统（如 NFS）写入巨大的检查点文件，可能瞬间打垮文件系统的元数据服务器，导致整个集群 I/O 卡死。
    *   **调试技巧**：采用分层、分片的异步保存策略。每个节点先将自己的分片写入本地高速存储（如 NVMe SSD），然后由一个后台进程池以受控的速率将这些分片上传到持久化的对象存储。这可以平滑 I/O 峰值，降低对共享资源的冲击。
